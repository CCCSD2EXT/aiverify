import { prepareChecklistExportData } from "./exportUtil.js";
import { importJson, jsonToChecklistSubmissions, extractChecklistData } from "./importUtils.js";

export const getConfigFiles = () => {
  const configKeys = [
    'accountability',
    'data_governance',
    'explainability',
    'fairness',
    'human_agency_oversight',
    'inclusive_growth_soc_env',
    'organisational_considerations',
    'reproducibility',
    'robustness',
    'safety',
    'security',
    'transparency'
  ];

const configFiles = {};
configKeys.forEach(key => {
try {
configFiles[`config_${key}`] = require(`./config_${key}.ts`).config;
} catch (err) {
console.error(`Failed to load config file for ${key}:`, err);
}
});

return configFiles;
};

export function exportAsJson(checklists) {
  // Get all config files
  const configFiles = getConfigFiles();

// Initialize the result object
const result = {
exportDate: new Date().toISOString(),
checklists: []
};

// Process each checklist
for (const checklist of checklists) {
// Extract the principle name from the cid (e.g., 'transparency' from 'transparency*process_checklist')
const principle = checklist.cid.replace('\_process_checklist', '');
const configKey = `config*${principle}`;

    // Get the corresponding config
    const config = configFiles[configKey];

    if (!config) {
      console.warn(`Config not found for principle: ${principle}`);
      continue; // Skip this checklist
    }

    // Create a structured object for this checklist
    const checklistData = {
      id: checklist.id,
      gid: checklist.gid,
      cid: checklist.cid,
      name: checklist.name,
      group: checklist.group,
      principle: config.principle,
      description: config.description,
      sections: []
    };

    // Process each section in the config
    for (const section of config.sections) {
      const sectionData = {
        section: section.section,
        testType: section.testType,
        criteria: []
      };

      // Process each testable criteria in the section
      for (const criteriaItem of section.checklist) {
        const criteriaData = {
          testableCriteria: criteriaItem.testableCriteria,
          processes: []
        };

        // Process each process in the criteria
        for (const process of criteriaItem.processes) {
          const pid = process.pid;

          // Get the completed and elaboration data from the checklist
          const completed = checklist.data[`completed-${pid}`] || '';
          const elaboration = checklist.data[`elaboration-${pid}`] || '';

          // Add the process data
          criteriaData.processes.push({
            pid: pid,
            process: process.process,
            metric: process.metric,
            processChecks: process.processChecks,
            completed: completed,
            elaboration: elaboration
          });
        }

        sectionData.criteria.push(criteriaData);
      }

      checklistData.sections.push(sectionData);
    }

    // Count completed processes
    let yesCount = 0;
    let totalProcesses = 0;

    for (const section of checklistData.sections) {
      for (const criteria of section.criteria) {
        for (const process of criteria.processes) {
          totalProcesses++;
          if (process.completed === 'Yes') {
            yesCount++;
          }
        }
      }
    }
    // Add the processed checklist to the result
    result.checklists.push(checklistData);

}

return result;
}

export async function prepareExportData(groupName, checklists) {
  try {
    // Get the config files
    const configFiles = getConfigFiles();

    // Use the function to prepare the Excel workbook definition
    const workbookDefinition = await prepareChecklistExportData(
      groupName,
      checklists,
      configFiles
    );

    return workbookDefinition;

} catch (error) {
console.error("Error preparing export data:", error);
return null;
}
}

export const mdxImportJson = importJson;
export const mdxJsonToChecklistSubmissions = jsonToChecklistSubmissions;
export const mdxExtractChecklistData = extractChecklistData;

export function ExportProcessChecklists(props) {
  const { groupName, checklists } = props;

return (

<div style={{ padding: "8px", color: "#666", fontSize: "14px" }}>
  <div>Export component is ready. This renderer is for preview only.</div>
  <div>Group: {groupName}</div>
  <div>Checklists: {checklists?.length || 0} items</div>
</div>
); }
